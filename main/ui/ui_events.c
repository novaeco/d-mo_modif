// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 8.3.11
// Project name: sq_ui

#include "ui.h"
#include "add_password.h"
#include "demos/lv_demos.h"
#include "usart.h"              // Include the USART driver for UART communication
#include "can.h"                // Include the CAN driver
#include "wifi.h"               // Include the WIFI driver

// Event callback for handling user input in the username field
// This function is triggered when the user interacts with the username input field.
void input_user_event_cb(lv_event_t * e)
{
	const char *text = lv_textarea_get_text(ui_Login_InputUser); // Retrieve text entered by the user
	// Save the entered username to a global variable
	strncpy(entered_username, text, MAX_LENGTH - 1);
	entered_username[MAX_LENGTH - 1] = '\0';  // Ensure null-termination
}

// Event callback for handling user input in the password field
// This function is triggered when the user interacts with the password input field.
void input_password_event_cb(lv_event_t * e)
{
	const char *text = lv_textarea_get_text(ui_Login_InputPass); // Retrieve text entered in the password field
	// Save the entered password to a global variable
	strncpy(entered_password, text, MAX_LENGTH - 1);
	entered_password[MAX_LENGTH - 1] = '\0';  // Ensure null-termination

	// Verify if the entered username matches the saved username
	if (strcmp(saved_username, entered_username) == 0) {
		// If the username is correct, proceed to check the password
		if (verify_credentials(entered_username, entered_password)) {
			// If credentials are correct, change the screen to the main screen
			_ui_screen_change(&ui_Main, LV_SCR_LOAD_ANIM_FADE_ON, 0, 0, &ui_Main_screen_init);
			// Logic for successful login can be added here
		} else {
			// If password is incorrect, clear the password field and show error messages
			lv_textarea_set_text(ui_Login_InputPass, ""); // Clear the password field
			_ui_flag_modify(ui_Login_Panel3, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
			_ui_flag_modify(ui_Login_Label3, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
		}
	} else {
		// If the username doesn't match, clear both username and password fields
		lv_textarea_set_text(ui_Login_InputUser, ""); 
		lv_textarea_set_text(ui_Login_InputPass, ""); 
		// Show error messages indicating invalid login
		_ui_flag_modify(ui_Login_Panel3, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
		_ui_flag_modify(ui_Login_Label3, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
	}
}

// Event callback for handling new username input
// This function is triggered when a user enters a new username while creating a new account.
void new_user_event_cb(lv_event_t * e)
{
	const char *text = lv_textarea_get_text(ui_Create_Uesr_Name); // Retrieve text entered in the username field
	// Save the new username to a global variable
	strncpy(saved_username, text, MAX_LENGTH - 1);
	saved_username[MAX_LENGTH - 1] = '\0';  // Ensure null-termination
}

// Event callback for handling new password input
// This function is triggered when the user enters a new password while creating a new account.
void mew_password_event_cb(lv_event_t * e)
{
	// Retrieve the text entered in the username field
	const char *text = lv_textarea_get_text(ui_Create_Uesr_Name);

	// If no username is entered, remove a label indicating a missing username
	if (strlen(text) == 0) {
		_ui_flag_modify(ui_Create_Uesr_Label3, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
	} else {
		// If username is entered, retrieve the text entered in the password field
		const char *text = lv_textarea_get_text(ui_Create_Uesr_Password);
		
		// Save the new password
		strncpy(saved_password, text, MAX_LENGTH - 1);
		saved_password[MAX_LENGTH - 1] = '\0';  // Ensure null-termination

		// Save both username and password to persistent storage
		save_credentials(saved_username, saved_password);

		// Change the state of the password input field to remove focus
		_ui_state_modify(ui_Create_Uesr_Password, LV_STATE_FOCUSED, _UI_MODIFY_STATE_REMOVE);
		
		// Show keyboard and label after password input
		_ui_flag_modify(ui_Create_Uesr_Keyboard0, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_ADD);
		_ui_flag_modify(ui_Create_Uesr_Label3, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_ADD);

		// Disable the password and username input fields after saving the credentials
		_ui_state_modify(ui_Create_Uesr_Password, LV_STATE_DISABLED, _UI_MODIFY_STATE_ADD);
		_ui_state_modify(ui_Create_Uesr_Name, LV_STATE_DISABLED, _UI_MODIFY_STATE_ADD);

		// Remove the button and label associated with creating a new user
		_ui_flag_modify(ui_Create_Uesr_Button0, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
		_ui_flag_modify(ui_Create_Uesr_Label2, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
	}
}


// RS485 transmission function
void RS485Send(lv_event_t * e)
{
	const char *text = lv_textarea_get_text(ui_RS485_Send_Area);
	UART_Write_Byte((uint8_t *)text);
	// Optionally, set the read area text (commented out)
	// lv_textarea_set_text(ui_RS485_Read_Area, text);
}

// RS485 baud rate configuration
void RS485Savebaud(lv_event_t * e)
{
	char buf[32];
    lv_roller_get_selected_str(ui_RS485_Roller1, buf, sizeof(buf));
	RS485_BaudRate = atoi(buf);
	// Set the UART baud rate based on the selected value
	UART_Set_Baudrate(RS485_BaudRate);
}

// Clear the RS485 read area
void RS485Clear(lv_event_t * e)
{
	lv_textarea_set_text(ui_RS485_Read_Area, ""); // Clear the read area
	RS485_Clear = true;
}

// CAN message sending function
void CANSend1(lv_event_t * e)
{
	const char *id = lv_textarea_get_text(ui_CAN_Send_ID);      // Get the CAN message ID from the input field
	const char *len = lv_textarea_get_text(ui_CAN_Send_Len);     // Get the CAN message length from the input field
	const char *data = lv_textarea_get_text(ui_CAN_Send_Data);   // Get the CAN message data from the input field

	// Convert the data for CAN message
	static twai_message_t message;
	message.identifier = strtoul(id, NULL, 16);   // Convert ID from string to unsigned long (hexadecimal)
	message.data_length_code = atoi(len);          // Convert data length from string to integer
	string_to_hex(data, message.data, MAX_HEX_DATA);  // Convert data from string to hexadecimal format
	/*此处可以添加如何输出格式错误，就不进行发送，否则会导致系统重启 */
	// Send the CAN message
	can_write_Byte(message);  // Transmit the message using the CAN interface
}

// Event callback to save the selected baud rate for CAN communication
void CANSavebaud(lv_event_t * e)
{
	char buf[32];
    lv_roller_get_selected_str(ui_CAN_Roller, buf, sizeof(buf));  // Get the selected baud rate from the dropdown
	can_uninstall();  // Uninstall the previous CAN configuration

	// TWAI configuration settings
    static twai_timing_config_t t_config = TWAI_TIMING_CONFIG_500KBITS();   // Set CAN bus speed to 500 kbps
    static const twai_filter_config_t f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL();   // Accept all incoming CAN messages
    static const twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT(TX_GPIO_NUM, RX_GPIO_NUM, TWAI_MODE_NORMAL); // General configuration, set TX/RX GPIOs and mode

	// Set timing configuration based on the selected baud rate
	if (strcmp(buf, "25K") == 0) {
		t_config.quanta_resolution_hz = 625000;
		t_config.tseg_1 = 16;
		t_config.tseg_2 = 8;
	} else if (strcmp(buf, "50K") == 0) {
		t_config.quanta_resolution_hz = 1000000;
		t_config.tseg_1 = 15;
		t_config.tseg_2 = 4;
	} else if (strcmp(buf, "100K") == 0) {
		t_config.quanta_resolution_hz = 2000000;
		t_config.tseg_1 = 15;
		t_config.tseg_2 = 4;
	} else if (strcmp(buf, "125K") == 0) {
		t_config.quanta_resolution_hz = 2500000;
		t_config.tseg_1 = 15;
		t_config.tseg_2 = 4;
	} else if (strcmp(buf, "250K") == 0) {
		t_config.quanta_resolution_hz = 5000000;
		t_config.tseg_1 = 15;
		t_config.tseg_2 = 4;
	} else if (strcmp(buf, "500K") == 0) {
		t_config.quanta_resolution_hz = 10000000;
		t_config.tseg_1 = 15;
		t_config.tseg_2 = 4;
	} else if (strcmp(buf, "800K") == 0) {
		t_config.quanta_resolution_hz = 20000000;
		t_config.tseg_1 = 16;
		t_config.tseg_2 = 8;
	} else if (strcmp(buf, "1M") == 0) {
		t_config.quanta_resolution_hz = 20000000;
		t_config.tseg_1 = 15;
		t_config.tseg_2 = 4;
	}
	
	// Initialize the CAN communication interface with the configured settings
    can_init(t_config, f_config, g_config);  // Initialize CAN with specified configurations
}

// Clear the CAN read area
void CANClear(lv_event_t * e)
{
	lv_textarea_set_text(ui_CAN_Read_Area, "");  // Clear the text area displaying received CAN messages
	CAN_Clear = true;  // Set CAN clear flag
}

// Event callback for opening the WiFi STA (station) connection
// This function opens a WiFi STA connection and modifies UI elements accordingly.
void WIFIOPEN(lv_event_t * e)
{
    // Open WiFi in STA mode (station mode)
    wifi_open_sta();
    
    // Disable the "Open WiFi" and "Open WiFi AP" buttons
    _ui_state_modify(ui_WIFI_OPEN, LV_STATE_DISABLED, _UI_MODIFY_STATE_ADD);
    _ui_state_modify(ui_WIFI_AP_OPEN, LV_STATE_DISABLED, _UI_MODIFY_STATE_ADD);
    
    // Show the loading spinner while scanning for available networks
    _ui_flag_modify(ui_WIFI_Spinner, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE); 
    
    // Set the WiFi scan flag to true
    WIFI_SCAN_FLAG = true;
}

// Event callback for closing the WiFi STA connection
// This function closes the WiFi STA connection and updates the UI.
void WIFICLOSE(lv_event_t * e)
{
    // Close the WiFi STA connection
    wifi_close_sta();
    
    // Clean the list of available WiFi networks
    lv_obj_clean(ui_WIFI_SCAN_List);
    
    // Show the WiFi details window (in case any details need to be shown)
    _ui_flag_modify(ui_WIFI_Details_Win, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_ADD);
}

// Event callback for establishing a WiFi connection
// This function connects to the WiFi using the entered password.
void WIFIConnection(lv_event_t * e)
{
    // Disable the "Open WiFi" button
    _ui_state_modify(ui_WIFI_OPEN, LV_STATE_DISABLED, _UI_MODIFY_STATE_ADD);
    
    // Get the password from the password input field
    wifi_pwd = (uint8_t *)lv_textarea_get_text(ui_WIFI_INPUT_PWD);
    
    // Set the WiFi STA flag to true, indicating an active connection attempt
    WIFI_STA_FLAG = true;
}

// Event callback for opening a WiFi Access Point (AP)
// This function sets up the AP mode with the provided SSID, password, and channel.
void WIFIAPOPEN(lv_event_t * e)
{
    // Get the SSID, password, and channel from the respective input fields
    const char *ssid = lv_textarea_get_text(ui_WIFI_AP_NAME);
    const char *pwd = lv_textarea_get_text(ui_WIFI_AP_Password);
    const char *channel = lv_textarea_get_text(ui_WIFI_AP_Channel);
    
    // Check if all the required fields (SSID, password, and channel) are provided
    if (ssid != NULL && strlen(ssid) > 0 && 
        pwd != NULL && strlen(pwd) > 0 && 
        channel != NULL && strlen(channel) > 0) {
        
        // If all fields are filled, initialize and open the AP
        wifi_open_ap();
        wifi_ap_init((uint8_t *)ssid, (uint8_t *)pwd, atoi(channel));
        
        // Set the WiFi AP flag to true, indicating the AP is active
        WIFI_AP_FLAG = true;
        
        // Update the label to show the number of connections (initially 0)
        lv_label_set_text(ui_WIFI_AP_CON_NUM, "Connected: 0");

    } else {
        // If one or more fields are empty, handle the error case
        printf("One or more fields are empty: SSID, Password or Channel \r\n");
        
        // Uncheck the "Open WiFi AP" button and show an error message
        _ui_state_modify(ui_WIFI_AP_OPEN, LV_STATE_CHECKED, _UI_MODIFY_STATE_REMOVE);
        _ui_flag_modify(ui_WIFI_AP_INPUT_ERROR, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_STATE_REMOVE);
    }
}

// Event callback for closing the WiFi Access Point (AP)
// This function closes the AP and disables the WiFi AP flag.
void WIFIAPCLOSE(lv_event_t * e)
{
    // Set the WiFi AP flag to false, indicating the AP is closed
    WIFI_AP_FLAG = false;
    
    // Close the WiFi AP connection
    wifi_close_ap();
}

